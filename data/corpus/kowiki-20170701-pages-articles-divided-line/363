커널 (컴퓨팅)

<link>컴퓨터 과학|컴퓨터 과학</link>에서 커널()은 <link>운영 체제|운영 체제</link>의 핵심 부분으로서, 운영 체제의 다른 부분 및 <link>응용 프로그램|응용 프로그램</link> 수행에 필요한 여러 가지 서비스를 제공한다.
 핵심(核心)이라고도 한다.

커널의 역할.
커널은 운영 체제의 핵심 부분이므로, 커널의 역할 역시 운영 체제의 핵심 역할이라 할 수 있다.
- 보안
- 자원 관리
- 추상화

역사.
초기의 커널.
초창기의 컴퓨터에서 운영 체제 커널은 필수적인 것이 아니었다.
 초기의 프로그램은 하드웨어 추상화나 운영 체제의 지원을 받지 않고도 컴퓨터만으로 불러들인 다음 실행될 수 있었으며, 이것은 초창기 컴퓨터들의 일반적인 운영 방식이었다.
 다른 프로그램을 실행하기 위해서는 컴퓨터의 전원을 껐다가 켬으로써 다시 입력자료를 읽어들여야 하는 방식이었다.
 이러한 과정이 반복되면서 사람들은 <link>로더|로더 (컴퓨팅)</link>와 <link>디버거|디버거</link> 같은 작은 프로그램들이 상주해 있는 것이, 다른 프로그램으로 교체하거나 새로운 프로그램을 개발하는 데 유리하다는 사실을 알게 되었다.
 이와 같은 로더, 디버거들이 초기 운영 체제 커널의 기초가 되었다.

종류.
- <link>단일형 커널|모놀리식 커널</link>(monolithic kernel) - 커널의 다양한 서비스 및 높은 수준의 하드웨어 추상화를 하나의 덩어리(주소 공간)로 묶은 것이다.
 운영 체제 개발자 입장에서 유지 보수가 일반적으로 더 어려우나 성능이 좋다.
- <link>마이크로커널|마이크로커널</link>(microkernel) - 하드웨어 추상화에 대한 간결한 작은 집합을 제공하고 더 많은 기능은 <link>서버|서버</link>라고 불리는 응용 소프트웨어를 통해 제공한다.
- <link>혼합형 커널|하이브리드 커널</link>(hybrid kernel) - 성능 향상을 위해 추가적인 코드를 커널 공간에 넣은 점을 제외하면 많은 부분은 순수 마이크로커널과 비슷하다.
 수정 마이크로커널이라고도 한다.
- <link>나노커널|마이크로커널#나노커널</link>(nanokernel) - 실질적으로 모든 서비스를 책임진다.
- <link>엑소커널|엑소커널</link>(exokernel) - 낮은 수준의 하드웨어 접근을 위한 최소한의 추상화를 제공한다.
 전형적으로 엑소커널 시스템에서는 커널이 아닌 <link>라이브러리|라이브러리 (컴퓨터)</link>가 단일형 커널 수준의 추상을 제공한다.

단일형 커널.
단일형 커널은 하드웨어 위에 높은 수준의 가상 계층을 정의한다.
 높은 수준의 가상 계층은 기본 연산 집합과 <link>관리자 모드|관리자 모드</link>에 작동하는 <link>모듈|모듈 (프로그래밍)</link>인 <link>프로세스|프로세스</link> 관리, <link>동시성|동시성 (컴퓨터)</link>, <link>메모리 관리|메모리 관리</link> 등의 운영 체제 서비스를 구현하기 위한 <link>시스템 콜|시스템 콜</link>으로 되어 있다.

이 연산들을 제공하는 모든 모듈이 전체로부터 분리되어 있더라도 모든 모듈이 같은 주소 공간에서 실행되기 때문에 코드의 집적도는 매우 조밀하며 수정하기 어렵고 한 모듈의 버그는 시스템 전반을 멈추게 할 수 있다.
 그러나 구현이 신뢰할 수 있을 정도로 완성되면 구성 요소의 내부 집적이 내부의 시스템 이용을 효과적이게 하여 좋은 단일형 커널은 높은 효율을 보인다.
 단일형 커널의 지지자들은 코드의 정확성 여부와 그런 코드(부정확한 코드)가 커널에 포함되었는지를 확인할 수 있고 그것은 마이크로커널에 비해 조금 더 우위에 있다고 주장한다.

<link>리눅스|리눅스</link>, <link>FreeBSD|FreeBSD</link>, <link>솔라리스|솔라리스 (운영 체제)</link>와 같은 최신의 단일형 커널은 실행 모듈을 실시간으로 읽어들일 수 있다.
 실시간으로 실행 모듈을 읽는 특징은 커널이 허용하는 범위 내에서 손쉽게 확장할 수 있게 커널 공간의 코드의 양을 최소한으로 유지시켜 준다.

<link>마이크로소프트|마이크로소프트</link> <link>윈도 NT|윈도 NT</link> 제품군(NT, 2000, XP, 2003, 비스타,7,8,8.1,10)은 처음에는 혼합형 커널이었으나 나중에 나온 것들은 단일형 커널로 바뀌었다.
 <link>윈도 NT|윈도 NT</link> 시리즈는 상위의 서비스들을 NT executive이라는 서버로 구현하였다.
 <link>Win32|Win32</link> 특성은 처음에는 사용자 모드의 서버 형태로 구현되었으나, 최근 버전에서는 관리자 주소 영역으로 이동하였다.
 다양한 서버들이 로컬 프로시저 콜(LPC: Local Procedure Call)이라 불리는 주소 영역간 매커니즘을 통해 통신하며, 성능을 최적화하기 위해 공유 메모리를 이용한다.

주로 다음 운영 체제들의 커널이 단일형 커널인 것으로 알려져 있다.

- <link>유닉스|유닉스</link>
- <link>BSD|BSD</link>
- <link>리눅스|리눅스</link>
- <link>솔라리스|솔라리스 (운영 체제)</link>
- <link>윈도 NT|윈도 NT</link>
- <link>벨로나2|벨로나2</link>
- <link>AIX|AIX (운영 체제)</link>
- <link>AGNIX|AGNIX</link>

마이크로커널.
마이크로커널은 하드웨어 위에 매우 간결한 추상화를 정의한다.
 기본 연산 집합과 운영 체제 서비스를 구현한 <link>스레드 관리|스레드 관리</link>, <link>주소 공간|주소 공간</link>, <link>프로세스간 통신|프로세스간 통신</link>의 작은 <link>시스템 콜|시스템 콜</link>으로 이루어져 있다.
 일반적으로 커널이 제공하는 <link>네트워킹|컴퓨터 네트워킹</link>과 같은 다른 서비스들은 사용자 공간 프로그램인 서버로 구현한다.

운영 체제는 서버를 다른 일반적인 프로그램처럼 간단히 시작하고 끌 수 있다.
 이를테면 네트워킹 지원이 필요 없는 작은 시스템에서는 간단히 서버를 끄면 된다.
 이 경우 전통적인 시스템에서는 <link>재컴파일|컴파일러</link>이 필요했고 일반 사용자의 능력 밖의 일이다.
 이론적으로 마이크로커널에서 시스템은 더 안정적이다.
 서버가 중단될 때 커널의 충돌이 아니기 때문에 단 하나의 프로그램만 내려버리면 된다.

그러나 서버가 실패한 후 시스템 상태도 잃어버릴 경우 응용 프로그램이 계속 수행되는 것은 그 응용 프로그램이 막 복사된 다른 서버를 이용하게 되더라도 보통은 매우 힘들다.
 예를 들어 <link>TCP/IP|TCP/IP</link> 연결을 요구하는 (이론적인) 서버가 다시 시작되면 응용 소프트웨어는 연결이 "끊어졌습니다.
"라고 말하고 서버의 새 인스턴스를 찾아서 다시 연결한다.
 그러나 파일과 같은 다른 시스템 객체는 이렇게 편리한 <link>의미론|의미론</link>이 없다.
 이러한 편리가 믿음직스럽지 못하고 마음대로 이용할 수 없다.
 기록할 정보들은 모두 미리 보관해 두어야 한다.
 서버 간의 하나의 서버를 다시 시작할 때 중요 상태를 보호하기 위해 <link>트랜잭션|데이터베이스 트랜잭션</link>, <link>복제|복제 (컴퓨터)</link>, <link>대조점|응용 대조점</link>의 <link>데이터베이스|데이터베이스</link> 기술이 요구된다.

일반적으로 마이크로커널은 전통적인 디자인의 수행을 잘못하고 때로는 극적이다.
 이유는 응용과 서버 간의 자료 교환을 위해 커널을 출입하는 <link>문맥 교환|문맥 교환</link> 때문이다.
 주의 깊은 조율이 오버헤드를 극적으로 줄여줄 것으로 믿어져 왔으나 90년대 중반부터 대부분의 연구원들은 시도를 포기했다.
 최근에 새 마이크로커널은 성능을 최우선으로 설계하며 이 문제를 넓은 부분에서 다루었다.
 그러나 현재 운영 체제 시장은 자기 몸 사리며 마이크로커널 설계에 소극적이다.

마이크로커널과 마이크로커널에 기반한 운영 체제의 예
- <link>AmigaOS|AmigaOS</link>
- <link>Amoeba|Amoeba</link>
- <link>ChorusOS|ChorusOS</link>
- <link>EROS|EROS</link>
- <link>Haiku|Haiku</link>
- <link>K42|K42</link>
- <link>LSE/OS|LSE/OS</link> (<link>나노커널|나노커널</link>)
- <link>KeyKOS|KeyKOS</link> (<link>나노커널|나노커널</link>)
- <link>L4 마이크로커널|L4 마이크로커널</link>
- <link>마하|마하</link> - <link>GNU 허드|GNU 허드</link>, <link>넥스트스텝|넥스트스텝</link>, <link>오픈스텝|오픈스텝</link>,<link>OS X|OS X</link>에 사용 됨.
- <link>MERT|MERT</link>
- <link>미닉스|미닉스</link>
- <link>MorphOS|MorphOS</link>
- <link>NewOS|NewOS</link>
- <link>QNX|QNX</link>
- <link>Phoenix-RTOS|Phoenix-RTOS</link>
- <link>RadiOS|RadiOS</link>
- <link>Spring operating system|Spring operating system</link>
- <link>VSTa|VSTa</link>
- <link>심비안 OS|심비안 OS</link>

혼합형 커널(수정 마이크로커널).
혼합형 커널은 본질적으로 마이크로커널을 따르나, 일부 커널의 비(非)본질적 기능이더라도 사용자 레벨에서 수행될 때 성능상 느린 코드들을 커널 레벨에서 수행하도록 수정한 것을 말한다.
 이는 다양한 운영 체제 개발자들이 마이크로커널 기반의 설계를 받아들이던 시점에 순수한 마이크로커널의 성능상의 한계를 인식하고 타협한 결과이다.
 다.

예를 들어, <link>OS X|OS X</link>의 커널인 <link>XNU|XNU</link>는 Mach 커널 3.0 마이크로커널에 기반을 두고 있지만, 전통적인 마이크로커널 설계의 지연 현상을 줄이기 위해 BSD 커널의 일부 코드들을 들여와 동일한 주소 영역에서 실행하고 있다.

<link>DragonFly BSD|DragonFly BSD</link>는 첫 번째 비 Mach 기반의 BSD OS로 혼합형 커널 구성을 적용한 예이다.

하이브리드 커널로는 다음과 같은 것들도 포함된다.
 다.
- <link>ReactOS|ReactOS</link>
- <link>BeOS|BeOS</link> 커널
- <link>넷웨어|넷웨어</link> 커널

혼합형 커널이라는 말을 부팅 후에 모듈을 읽어들일 수 있는 단일형 커널과 혼용하는 사람들이 있다.
 이것은 사실이 아니다.
 혼합형 커널은 단일형 커널과 마이크로커널 설계 양쪽의 구조적 개념과 작동방법에 대한 특히 메시지 전달과 어떤 중요하지 않은 코드는 사용자 공간에 들어가는 반면 어떤 코드는 성능의 이유로 커널 공간에 포함해야 하는지에 대한 문제의식을 가진다.

엑소커널.
엑소커널은 <link>운영 체제|운영 체제</link> 설계에 대한 급진적인 신개념으로 <link>말단 이론|말단 이론</link>을 따르는 수직 구조의 운영 체제이다.
엑소커널의 구상은 개발자에게 강제적인 추상화를 줄여 하드웨어 추상화에 대해 선택지를 다양하게 하는 것이다.
 엑소커널은 기능이 보호를 보장하는 것과 자원을 <link>분배|분배</link>하는 것만 하기에 매우 작아 편익보다 단순함을 제공한다.
 이런 특성은 오히려 모든 사용자가 각기 실제 호스트 컴퓨터의 자원을 <link>모방한|에뮬레이터</link> 컴퓨터를 받는<link>VM/370|VM (운영 체제)</link> 운영 체제와 비슷하다.
 반면에 모놀리식 커널이든 마이크로 커널이든 전통적인 커널 설계는 <link>하드웨어 추상화 계층|하드웨어 추상화 계층</link>(HAL)이나 장치 드라이버 아래 자원을 숨김으로써 하드웨어를 추상화한다.
 한 예로 전통적인 시스템에서 물리 메모리가 할당할 때 실제 위치를 알려주지 않기 때문에 오프셋과 <link>기억 관리 장치|기억 관리 장치</link>를 통해서만 문제를 해결 할 수 있다.

노커널.
<link>TUNES Project|TUNES</link> <a href="http%3A//tunes.org"></a>와 <link>UnununiumOS|UnununiumOS</link> <a href="http%3A//www.unununium.org"></a>는 노커널<a href="http%3A//cliki.tunes.org/No-Kernel"></a> 실험이다.
 노커널 소프트웨어는 단일 중앙 입구의 제약이 없다.

모놀리식 커널 대 마이크로 커널 논쟁.
1990년대 초기 모놀리식 커널은 진부한 것으로 여겨졌다.
 <link>리누스 토르발스|리누스 토르발스</link>와 <link>앤드류 타넨바움|앤드류 타넨바움</link>간에 일어난 <link>리눅스|리눅스</link>의 설계인 모놀리식 커널과 마이크로커널에 대한 <link>프레임 워|프레임 워</link>는 유명했다.
<a href="http%3A//www.dina.dk/%7Eabraham/Linus_vs_Tanenbaum.html"></a> <a href="http%3A//www.google.com/groups%3Fthreadm%3D12595%2540star.cs.vu.nl"></a>

타넨바움과 토르발스의 토론에 제시된 두 진영의 의견은 일장일단이 있다.

두 진영의 성공 사례가 있다.
 모놀리식 커널은 정확한 설계가 쉽고 마이크로커널 기반 시스템보다 빨리 성장할 수 있다.
 반대로, 마이크로커널은 종종 임베디드 로봇 산업이나 의료 컴퓨터 등에 이용될 수 있다.
 운영 체제의 컴포넌트를 개인적으로 가지고 있고 메모리 공간을 보호하기 때문이다.
 근대의 모듈을 읽어오는 모놀리식 커널에서도 이런 것은 불가능하다.

<link>Mach|Mach</link>는 일반적인 용도의 마이크로커널로 알려졌지만 특별한 용도로 설계된 마이크로커널도 있다.
 <link>L3|L4 마이크로커널</link>는 마이크로커널이 느리지 않다는 것을 보여주기 위해 만들어졌다.
 <link>L4|L4 마이크로커널</link>는 L3의 후예로 <link>Fiasco|Fiasco</link> 구현으로 대중적인데 L4 프로세스들과 별도의 공간에서 <link>리눅스|리눅스</link> 구동이 가능하다.
 이런 특성의 스크린숏은 freshmeat.net에서 구할 수 있다.
 <link>Pistachio|Pistachio</link>라 불리는 새 버전도 역시 가능하다.

<link>QNX|QNX</link>는 1980년 초에 나타난 운영 체제로 극 최소주의 마이크로커널 설계로 이루어졌다.
 이 시스템은 Mach가 목표로 했던 마이크로커널 이념을 더 성공적으로 이루었다.
 QNX는 <link>우주 왕복선|우주 왕복선</link>의 로봇 팔과 (작은 실수가 수십억의 손실을 입히는 <link>허블 우주망원경|허블 우주망원경</link>의 거울 등의) 오차에 민감한 유리를 닦는 기계에도 적용되었다.

같이 보기.
- <link>운영 체제|운영 체제</link>
- <link>셸|셸</link>

바깥 고리.
- <a href="http%3A//sourceforge.net/softwaremap/trove_list.php%3Fform_cat%3D144">소스포지의 운영 체제 커널</a>
- <a href="http%3A//freshmeat.net/browse/144/">Freshmeat의 운영 체제 커널</a>
- <a href="http%3A//www.pdos.lcs.mit.edu/exo.html">MIT 엑소커널 운영 체제</a>
- <a href="http%3A//www.cis.upenn.edu/%7EKeyKOS/NanoKernel/NanoKernel.html">KeyKOS 나노커널 구조</a>, <link>1992년|1992년</link> <link>노르만 하르디|노르만 하르디</link>저
- <a href="http%3A//www.usenix.org/publications/library/proceedings/sf94/full_papers/minshall.a">넷웨어 운영 체제 개론</a>, <link>1994년|1994년</link> Drew Major, Greg Minshall, Kyle Powell 저 (넷웨어 운영 체제 뒤의 기본 구조).


